rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isGameParticipant(gameData) {
      return isSignedIn() && 
        (gameData.players[request.auth.uid] != null || 
         gameData.players[request.auth.uid].isActive == true);
    }
    
    function isGameJudge(gameData) {
      return isSignedIn() && 
        gameData.players[request.auth.uid] != null && 
        gameData.players[request.auth.uid].isJudge == true;
    }
    
    function isGameCreator(gameData) {
      return isSignedIn() && gameData.createdBy == request.auth.uid;
    }
    
    function isValidGameData() {
      let incomingData = request.resource.data;
      return incomingData.players is map &&
             incomingData.rounds is list &&
             incomingData.currentRound is number &&
             incomingData.maxRounds is number &&
             incomingData.status is string;
    }
    
    function isValidPromptData() {
      let incomingData = request.resource.data;
      return incomingData.text is string &&
             incomingData.id is string;
    }
    
    function isValidSubmissionData() {
      let incomingData = request.resource.data;
      return incomingData.gifId is string &&
             incomingData.gifUrl is string &&
             incomingData.playerId is string &&
             incomingData.playerName is string &&
             incomingData.round is string;
    }

    // Users: Basic self-management
    match /users/{userId} {
      allow read: if isSignedIn();
      allow write: if isOwner(userId);
    }

    // Games: Core game logic rules
    match /games/{gameId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isValidGameData();
      allow update: if isSignedIn() && (
        // Allow updates if user is a participant
        isGameParticipant(resource.data) ||
        // Allow updates if user is the judge and updating prompt-related fields
        (isGameJudge(resource.data) && (
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['rounds']) ||
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['currentRound']) ||
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['status'])
        )) ||
        // Allow updates if user is the judge and selecting a winner
        (isGameJudge(resource.data) && 
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['rounds']) &&
         request.resource.data.rounds[-1].winningSubmission != null)
      );
      allow delete: if isGameCreator(resource.data);

      // Only an authenticated user creating a game where they are the host
      allow create: if request.auth != null
                       && request.resource.data.hostId == request.auth.uid;

      // Update rules: Handle host actions, joining, and playing
      allow update: if request.auth != null && (
        // Condition 1: The user is the host (allow broad updates)
        resource.data.hostId == request.auth.uid ||

        // Condition 2: A player is joining the game
        isPlayerJoining(request, resource) ||

        // Condition 3: A player is submitting to their round
        isPlayerSubmittingRound(request, resource) ||
        
        // Condition 4: The current judge is updating the prompt
        isJudgeUpdatingPrompt(request, resource) ||
        
        // Condition 5: The current judge is starting the round
        isJudgeStartingRound(request, resource) ||
        
        // Condition 6: The current judge is selecting a winner
        isJudgeSelectingWinner(request, resource)
      );

      // --- Helper Functions ---

      // Checks if the request corresponds to a player joining the game
      function isPlayerJoining(req, res) {
        // Get the data before (res.data) and after (req.resource.data) the potential update
        let before = res.data;
        let after = req.resource.data;
        // Identify the fields that changed
        let changedKeys = after.diff(before).affectedKeys();
        // The player being added (will be the last element in the 'after' state)
        // Ensure there's at least one player before accessing index 0
        let newPlayer = before.players.size() == 0 ? after.players[0] : after.players[before.players.size()];

        // Check all conditions for a valid join operation:
        return
          // 1. Only 'players' and potentially 'updatedAt' fields are allowed to change
          (changedKeys.hasOnly(['players']) || changedKeys.hasOnly(['players', 'updatedAt'])) &&
          // 2. Exactly one player is being added
          (after.players.size() == before.players.size() + 1) &&
          // 3. The ID of the player being added matches the authenticated user
          (newPlayer.id == req.auth.uid) &&
          // 4. Validate the structure of the player object being added
          (newPlayer.name is string && newPlayer.name.size() > 0) && // Ensure name is provided
          (newPlayer.isHost == false) && // Cannot join as host
          (newPlayer.isJudge == false) && // Cannot join as judge initially
          (newPlayer.score == 0) &&       // Initial score must be 0
          (newPlayer.isActive == true);  // Player starts as active
      }

      // Checks if the request corresponds to a player submitting to their round
      function isPlayerSubmittingRound(req, res) {
         let before = res.data;
         let after = req.resource.data;
         let changedKeys = after.diff(before).affectedKeys();
         let userId = req.auth.uid;
         let currentRoundIdx = before.currentRound - 1;

         // Check conditions for submitting a round:
         return
           // 1. Only allow changes to 'rounds' and optionally 'updatedAt' fields
           (changedKeys.hasOnly(['rounds']) || changedKeys.hasOnly(['rounds', 'updatedAt'])) &&
           // 2. Make sure the current round index is valid
           currentRoundIdx >= 0 && 
           currentRoundIdx < before.rounds.size() &&
           // 3. Make sure user is not the judge for the current round
           before.rounds[currentRoundIdx].judgeId != userId &&
           // 4. Check that the submissions array is growing in the current round
           after.rounds.size() == before.rounds.size() &&
           after.rounds[currentRoundIdx].submissions.size() > before.rounds[currentRoundIdx].submissions.size() &&
           // 5. Verify the new submission belongs to the current user
           after.rounds[currentRoundIdx].submissions[after.rounds[currentRoundIdx].submissions.size() - 1].playerId == userId;
      }
      
      // Checks if the current judge is updating the prompt
      function isJudgeUpdatingPrompt(req, res) {
        let before = res.data;
        let after = req.resource.data;
        let changedKeys = after.diff(before).affectedKeys();
        let userId = req.auth.uid;
        let currentRoundIdx = before.currentRound - 1;
        
        // Check conditions for judge updating prompt:
        return
          // 1. Only allow changes to 'rounds' and optionally 'updatedAt' fields
          (changedKeys.hasOnly(['rounds']) || changedKeys.hasOnly(['rounds', 'updatedAt'])) &&
          // 2. Make sure the current round index is valid
          currentRoundIdx >= 0 && 
          currentRoundIdx < before.rounds.size() &&
          // 3. Make sure user is the judge for the current round
          before.rounds[currentRoundIdx].judgeId == userId &&
          // 4. Check that the prompt is being updated
          after.rounds.size() == before.rounds.size() &&
          after.rounds[currentRoundIdx].prompt.id != before.rounds[currentRoundIdx].prompt.id;
      }
      
      // Checks if the current judge is starting the round
      function isJudgeStartingRound(req, res) {
        let before = res.data;
        let after = req.resource.data;
        let changedKeys = after.diff(before).affectedKeys();
        let userId = req.auth.uid;
        let currentRoundIdx = before.currentRound - 1;
        
        // Check conditions for judge starting the round:
        return
          // 1. Only allow changes to 'rounds' and optionally 'updatedAt' fields
          (changedKeys.hasOnly(['rounds']) || changedKeys.hasOnly(['rounds', 'updatedAt'])) &&
          // 2. Make sure the current round index is valid
          currentRoundIdx >= 0 && 
          currentRoundIdx < before.rounds.size() &&
          // 3. Make sure user is the judge for the current round
          before.rounds[currentRoundIdx].judgeId == userId &&
          // 4. Check that the hasStarted field is being updated to true
          after.rounds.size() == before.rounds.size() &&
          before.rounds[currentRoundIdx].hasStarted == false &&
          after.rounds[currentRoundIdx].hasStarted == true;
      }
      
      // Checks if the current judge is selecting a winner
      function isJudgeSelectingWinner(req, res) {
        let before = res.data;
        let after = req.resource.data;
        let changedKeys = after.diff(before).affectedKeys();
        let userId = req.auth.uid;
        let currentRoundIdx = before.currentRound - 1;
        
        // Check conditions for judge selecting a winner:
        return
          // 1. Only allow changes to 'rounds', 'players', 'status', and optionally 'updatedAt' fields
          (changedKeys.hasOnly(['rounds', 'players', 'status']) || 
           changedKeys.hasOnly(['rounds', 'players', 'status', 'updatedAt'])) &&
          // 2. Make sure the current round index is valid
          currentRoundIdx >= 0 && 
          currentRoundIdx < before.rounds.size() &&
          // 3. Make sure user is the judge for the current round
          before.rounds[currentRoundIdx].judgeId == userId &&
          // 4. Check that the winningSubmission is being set
          after.rounds.size() == before.rounds.size() &&
          before.rounds[currentRoundIdx].winningSubmission == null &&
          after.rounds[currentRoundIdx].winningSubmission != null &&
          // 5. Check that the round is being marked as complete
          before.rounds[currentRoundIdx].isComplete == false &&
          after.rounds[currentRoundIdx].isComplete == true;
      }
    }

    // Prompts collection
    match /prompts/{promptId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && isValidPromptData();
    }
    
    // Submissions collection
    match /submissions/{submissionId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isValidSubmissionData();
      allow update, delete: if isSignedIn() && 
        (resource.data.playerId == request.auth.uid || 
         isGameJudge(get(/databases/$(database)/documents/games/$(resource.data.gameId)).data));
    }
  }
}